package tftmpl

import (
	"fmt"
	"io"
	"log"
	"os"
	"path"

	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/hashicorp/hcl/v2/hclwrite"
	"github.com/zclconf/go-cty/cty"
)

const (
	// TerraformRequiredVersion is the version constraint pinned to the generated
	// root module to ensure compatibility across Consul NIA, Terraform, and
	// modules.
	TerraformRequiredVersion = ">=0.13"

	// RootFilename is the file name for the root module.
	RootFilename = "main.tf"

	// VarsFilename is the file name for the variable definitions in the root module
	VarsFilename = "variables.tf"
)

// RootPreamble is a warning message included to the beginning of the
// generated root module files.
var RootPreamble = []byte(
	`# This file is generated by Consul NIA.
#
# The HCL blocks, arguments, variables, and values are derived from the
# operator configuration for Consul NIA. Any manual changes to this file
# may not be preserved and could be clobbered by a subsequent update.

`)

// Task contains information for a Consul NIA task. The Terraform driver
// interprets task values for determining the Terraform module.
type Task struct {
	Description string
	Name        string
	Source      string
	Version     string
}

// RootModuleInputData is the input data used to generate the root module
type RootModuleInputData struct {
	Backend   map[string]interface{}
	Providers []map[string]interface{}
	Task      Task

	backend   *namedBlock
	providers []*namedBlock
}

// NewRootModuleInputData initializes input data used to generate a Terraform
// root module. It converts the parameters into HCL objects compatible for
// Terraform configuration syntax.
func NewRootModuleInputData(backend map[string]interface{},
	providers []map[string]interface{}, task Task) *RootModuleInputData {

	data := RootModuleInputData{
		Backend:   backend,
		Providers: providers,
		Task:      task,
	}

	data.backend = newNamedBlock(backend)
	data.providers = make([]*namedBlock, len(providers))
	for i, p := range providers {
		data.providers[i] = newNamedBlock(p)
	}
	return &data
}

// InitRootModule generates the root module and writes the following files to
// disk: main.tf, variables.tf
func InitRootModule(input *RootModuleInputData, dir string, force bool) error {
	modulePath := path.Join(dir, input.Task.Name)
	os.MkdirAll(modulePath, os.ModePerm)

	// Handle main.tf
	mainPath := path.Join(modulePath, RootFilename)
	exists := fileExists(mainPath)
	switch {
	case exists && !force:
		log.Printf("[DEBUG] (templates.terraform) %s in root module for task %q "+
			"already exists, skipping file creation", RootFilename, input.Task.Name)

	case exists && force:
		log.Printf("[INFO] (templates.terraform) overwriting %s in root module "+
			"for task %q", RootFilename, input.Task.Name)
		fallthrough

	default:
		log.Printf("[DEBUG] (templates.terraform) creating %s in root module for "+
			"task %q: %s", RootFilename, input.Task.Name, mainPath)
		f, err := os.Create(mainPath)
		if err != nil {
			log.Printf("[ERR]")
			return err
		}
		if err := NewMainTF(f, input); err != nil {
			log.Printf("[ERR]")
			return err
		}
	}

	// Handle variables.tf
	varPath := path.Join(modulePath, VarsFilename)
	exists = fileExists(varPath)
	switch {
	case exists && !force:
		log.Printf("[DEBUG] (templates.terraform) %s in root module for task %q "+
			"already exists, skipping file creation", VarsFilename, input.Task.Name)

	case exists && force:
		log.Printf("[INFO] (templates.terraform) overwriting %s in root module "+
			"for task %q", VarsFilename, input.Task.Name)
		fallthrough

	default:
		log.Printf("[DEBUG] (templates.terraform) creating %s in root module for "+
			"task %q: %s", VarsFilename, input.Task.Name, varPath)
		f, err := os.Create(varPath)
		if err != nil {
			log.Printf("[ERR]")
			return err
		}
		if err := NewVariablesTF(f, input); err != nil {
			log.Printf("[ERR]")
			return err
		}
	}

	return nil
}

// NewMainTF writes content used for main.tf of a Terraform root module.
func NewMainTF(w io.Writer, input *RootModuleInputData) error {
	_, err := w.Write(RootPreamble)
	if err != nil {
		// This isn't required for TF config files to be usable. So we'll just log
		// the error and continue.
		log.Printf("[WARN] (templates.terraform) unable to write preamble warning to %q",
			RootFilename)
	}

	hclFile := hclwrite.NewEmptyFile()
	rootBody := hclFile.Body()
	appendRootTerraformBlock(rootBody, input.backend)
	rootBody.AppendNewline()
	appendRootProviderBlocks(rootBody, input.providers)
	rootBody.AppendNewline()
	appendRootModuleBlock(rootBody, input.Task)

	_, err = hclFile.WriteTo(w)
	return err
}

// appendRootTerraformBlock appends the Terraform block with version constraint
// and backend.
func appendRootTerraformBlock(body *hclwrite.Body, backend *namedBlock) {
	tfBlock := body.AppendNewBlock("terraform", nil)
	tfBody := tfBlock.Body()
	tfBody.SetAttributeValue("required_version", cty.StringVal(TerraformRequiredVersion))

	// Configure the Terraform backend within the Terraform block
	backendBody := tfBody.AppendNewBlock("backend", []string{backend.Name}).Body()
	backendAttrs := backend.SortedAttributes()
	for _, attr := range backendAttrs {
		backendBody.SetAttributeValue(attr, backend.Block[attr])
	}
}

// appendRootProviderBlocks appends Terraform provider blocks for the providers
// the task requires.
func appendRootProviderBlocks(body *hclwrite.Body, providers []*namedBlock) {
	lastIdx := len(providers) - 1
	for i, p := range providers {
		providerBody := body.AppendNewBlock("provider", []string{p.Name}).Body()

		// Convert user provider attr+values to provider block arguments from variables
		// and sort the attributes for consistency
		// attr = var.<providerName>.<attr>
		providerAttrs := p.SortedAttributes()
		for _, attr := range providerAttrs {
			// Drop the alias meta attribute. Each provider instance will be ran as
			// a separate task
			if attr == "alias" {
				continue
			}

			providerBody.SetAttributeTraversal(attr, hcl.Traversal{
				hcl.TraverseRoot{Name: "var"},
				hcl.TraverseAttr{Name: p.Name},
				hcl.TraverseAttr{Name: attr},
			})
		}
		if i != lastIdx {
			body.AppendNewline()
		}
	}
}

// appendRootModuleBlock appends a Terraform module block for the task
func appendRootModuleBlock(body *hclwrite.Body, task Task) {
	// Add user description for task above the module block
	if task.Description != "" {
		appendComment(body, task.Description)
	}

	moduleBlock := body.AppendNewBlock("module", []string{task.Name})
	moduleBody := moduleBlock.Body()
	moduleBody.SetAttributeValue("source", cty.StringVal(task.Source))
	if len(task.Version) > 0 {
		moduleBody.SetAttributeValue("version", cty.StringVal(task.Version))
	}
	body.AppendNewline()
	moduleBody.SetAttributeTraversal("services", hcl.Traversal{
		hcl.TraverseRoot{Name: "var"},
		hcl.TraverseAttr{Name: "services"},
	})
}

// appendComment appends a single HCL comment line
func appendComment(b *hclwrite.Body, comment string) {
	b.AppendUnstructuredTokens(hclwrite.Tokens{
		{
			Type:  hclsyntax.TokenComment,
			Bytes: []byte(fmt.Sprintf("# %s", comment)),
		},
	})
	b.AppendNewline()
}

func fileExists(name string) bool {
	if _, err := os.Stat(name); err != nil {
		if os.IsNotExist(err) {
			return false
		}
	}
	return true
}
