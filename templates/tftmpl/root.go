package tftmpl

import (
	"fmt"
	"io"
	"log"
	"os"
	"path"
	"sort"

	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/hashicorp/hcl/v2/hclwrite"
	"github.com/hashicorp/terraform/configs/hcl2shim"
	"github.com/zclconf/go-cty/cty"
)

const (
	// TerraformRequiredVersion is the version constraint pinned to the generated
	// root module to ensure compatibility across Consul NIA, Terraform, and
	// modules.
	TerraformRequiredVersion = ">=0.13"

	// RootFilename is the file name for the root module.
	RootFilename = "main.tf"

	// VarsFilename is the file name for the variable definitions in the root module
	VarsFilename = "variables.tf"
)

// RootPreamble is a warning message included to the beginning of the
// generated root module files.
var RootPreamble = []byte(
	`# This file is generated by Consul NIA.
#
# The HCL blocks, arguments, variables, and values are derived from the
# operator configuration for Consul NIA. Any manual changes to this file
# may not be preserved and could be clobbered by a subsequent update.

`)

// Task contains information for a Consul NIA task. The Terraform driver
// interprets task values for determining the Terraform module.
type Task struct {
	Description string
	Name        string
	Source      string
	Version     string
}

type Service struct {
	Datacenter  string
	Description string
	Name        string
	Namespace   string
	Tag         string
}

// TODO incorporate namespace
func (s Service) TemplateServiceID() string {
	id := s.Name

	if s.Tag != "" {
		id = fmt.Sprintf("%s.%s", s.Tag, s.Name)
	}

	if s.Datacenter != "" {
		id = fmt.Sprintf("%s@%s", id, s.Datacenter)
	}

	return id
}

// RootModuleInputData is the input data used to generate the root module
type RootModuleInputData struct {
	Backend      map[string]interface{}
	Providers    []map[string]interface{}
	ProviderInfo map[string]interface{}
	Services     []*Service
	Task         Task

	backend   *namedBlock
	providers []*namedBlock
	services  []*Service
}

// Init processes input data used to generate a Terraform root module. It
// converts the RootModuleInputData values into HCL objects compatible for
// Terraform configuration syntax.
func (d *RootModuleInputData) Init() {
	if d.Backend != nil {
		d.backend = newNamedBlock(d.Backend)
	} else {
		d.Backend = make(map[string]interface{})
	}

	d.providers = make([]*namedBlock, len(d.Providers))
	for i, p := range d.Providers {
		d.providers[i] = newNamedBlock(p)
	}
	sort.Slice(d.providers, func(i, j int) bool {
		return d.providers[i].Name < d.providers[j].Name
	})

	d.services = d.Services
	sort.Slice(d.services, func(i, j int) bool {
		return d.services[i].Name < d.services[j].Name
	})
}

// InitRootModule generates the root module and writes the following files to
// disk: main.tf, variables.tf
func InitRootModule(input *RootModuleInputData, dir string, force bool) error {
	modulePath := path.Join(dir, input.Task.Name)
	os.MkdirAll(modulePath, os.ModePerm)

	// Handle main.tf
	mainPath := path.Join(modulePath, RootFilename)
	exists := fileExists(mainPath)
	switch {
	case exists && !force:
		log.Printf("[DEBUG] (templates.tftmpl) %s in root module for task %q "+
			"already exists, skipping file creation", RootFilename, input.Task.Name)

	case exists && force:
		log.Printf("[INFO] (templates.tftmpl) overwriting %s in root module "+
			"for task %q", RootFilename, input.Task.Name)
		fallthrough

	default:
		log.Printf("[DEBUG] (templates.tftmpl) creating %s in root module for "+
			"task %q: %s", RootFilename, input.Task.Name, mainPath)
		f, err := os.Create(mainPath)
		if err != nil {
			log.Printf("[ERR] (templates.tftmpl) unable to create %s in root "+
				"module for %q: %s", RootFilename, input.Task.Name, err)
			return err
		}
		if err := NewMainTF(f, input); err != nil {
			log.Printf("[ERR] (templates.tftmpl) error writing content for %s in "+
				"root module for %q: %s", RootFilename, input.Task.Name, err)
			return err
		}
	}

	// Handle variables.tf
	varPath := path.Join(modulePath, VarsFilename)
	exists = fileExists(varPath)
	switch {
	case exists && !force:
		log.Printf("[DEBUG] (templates.tftmpl) %s in root module for task %q "+
			"already exists, skipping file creation", VarsFilename, input.Task.Name)

	case exists && force:
		log.Printf("[INFO] (templates.tftmpl) overwriting %s in root module "+
			"for task %q", VarsFilename, input.Task.Name)
		fallthrough

	default:
		log.Printf("[DEBUG] (templates.tftmpl) creating %s in root module for "+
			"task %q: %s", VarsFilename, input.Task.Name, varPath)
		f, err := os.Create(varPath)
		if err != nil {
			log.Printf("[ERR] (templates.tftmpl) unable to create %s in root "+
				"module for %q: %s", VarsFilename, input.Task.Name, err)
			return err
		}
		if err := NewVariablesTF(f, input); err != nil {
			log.Printf("[ERR] (templates.tftmpl) error writing content for %s in "+
				"root module for %q: %s", VarsFilename, input.Task.Name, err)
			return err
		}
	}

	// Handle *.tfvars.tmpl
	tfvarsFilename := TFVarsFilename(input.Task.Name)
	tfvarsPath := path.Join(modulePath, tfvarsFilename)
	exists = fileExists(tfvarsPath)
	switch {
	case exists && !force:
		log.Printf("[DEBUG] (templates.tftmpl) %s in root module for task %q "+
			"already exists, skipping file creation", tfvarsFilename, input.Task.Name)

	case exists && force:
		log.Printf("[INFO] (templates.tftmpl) overwriting %s in root module "+
			"for task %q", tfvarsFilename, input.Task.Name)
		fallthrough

	default:
		log.Printf("[DEBUG] (templates.tftmpl) creating %s in root module for "+
			"task %q: %s", tfvarsFilename, input.Task.Name, tfvarsPath)
		f, err := os.Create(tfvarsPath)
		if err != nil {
			log.Printf("[ERR] (templates.tftmpl) unable to create %s in root "+
				"module for %q: %s", tfvarsFilename, input.Task.Name, err)
			return err
		}
		if err := NewTFVarsTmpl(f, input); err != nil {
			log.Printf("[ERR] (templates.tftmpl) error writing content for %s in "+
				"root module for %q: %s", tfvarsFilename, input.Task.Name, err)
			return err
		}
	}

	return nil
}

// NewMainTF writes content used for main.tf of a Terraform root module.
func NewMainTF(w io.Writer, input *RootModuleInputData) error {
	_, err := w.Write(RootPreamble)
	if err != nil {
		// This isn't required for TF config files to be usable. So we'll just log
		// the error and continue.
		log.Printf("[WARN] (templates.tftmpl) unable to write preamble warning to %q",
			RootFilename)
	}

	hclFile := hclwrite.NewEmptyFile()
	rootBody := hclFile.Body()
	appendRootTerraformBlock(rootBody, input.backend, input.ProviderInfo)
	rootBody.AppendNewline()
	appendRootProviderBlocks(rootBody, input.providers)
	rootBody.AppendNewline()
	appendRootModuleBlock(rootBody, input.Task)

	_, err = hclFile.WriteTo(w)
	return err
}

// appendRootTerraformBlock appends the Terraform block with version constraint
// and backend.
func appendRootTerraformBlock(body *hclwrite.Body, backend *namedBlock,
	providerInfo map[string]interface{}) {

	tfBlock := body.AppendNewBlock("terraform", nil)
	tfBody := tfBlock.Body()
	tfBody.SetAttributeValue("required_version", cty.StringVal(TerraformRequiredVersion))

	if len(providerInfo) != 0 {
		requiredProvidersBody := tfBody.AppendNewBlock("required_providers", nil).Body()
		for _, pName := range sortedKeys(providerInfo) {
			info, ok := providerInfo[pName]
			if ok {
				requiredProvidersBody.SetAttributeValue(pName, hcl2shim.HCL2ValueFromConfigValue(info))
			}
		}
	}

	// Configure the Terraform backend within the Terraform block
	if backend == nil {
		return
	}
	backendBody := tfBody.AppendNewBlock("backend", []string{backend.Name}).Body()
	backendAttrs := backend.SortedAttributes()
	for _, attr := range backendAttrs {
		backendBody.SetAttributeValue(attr, backend.Block[attr])
	}
}

// appendRootProviderBlocks appends Terraform provider blocks for the providers
// the task requires.
func appendRootProviderBlocks(body *hclwrite.Body, providers []*namedBlock) {
	lastIdx := len(providers) - 1
	for i, p := range providers {
		providerBody := body.AppendNewBlock("provider", []string{p.Name}).Body()

		// Convert user provider attr+values to provider block arguments from variables
		// and sort the attributes for consistency
		// attr = var.<providerName>.<attr>
		providerAttrs := p.SortedAttributes()
		for _, attr := range providerAttrs {
			// Drop the alias meta attribute. Each provider instance will be ran as
			// a separate task
			if attr == "alias" {
				continue
			}

			providerBody.SetAttributeTraversal(attr, hcl.Traversal{
				hcl.TraverseRoot{Name: "var"},
				hcl.TraverseAttr{Name: p.Name},
				hcl.TraverseAttr{Name: attr},
			})
		}
		if i != lastIdx {
			body.AppendNewline()
		}
	}
}

// appendRootModuleBlock appends a Terraform module block for the task
func appendRootModuleBlock(body *hclwrite.Body, task Task) {
	// Add user description for task above the module block
	if task.Description != "" {
		appendComment(body, task.Description)
	}

	moduleBlock := body.AppendNewBlock("module", []string{task.Name})
	moduleBody := moduleBlock.Body()
	moduleBody.SetAttributeValue("source", cty.StringVal(task.Source))
	if len(task.Version) > 0 {
		moduleBody.SetAttributeValue("version", cty.StringVal(task.Version))
	}
	body.AppendNewline()
	moduleBody.SetAttributeTraversal("services", hcl.Traversal{
		hcl.TraverseRoot{Name: "var"},
		hcl.TraverseAttr{Name: "services"},
	})
}

// appendComment appends a single HCL comment line
func appendComment(b *hclwrite.Body, comment string) {
	b.AppendUnstructuredTokens(hclwrite.Tokens{
		{
			Type:  hclsyntax.TokenComment,
			Bytes: []byte(fmt.Sprintf("# %s", comment)),
		},
	})
	b.AppendNewline()
}

func fileExists(name string) bool {
	if _, err := os.Stat(name); err != nil {
		if os.IsNotExist(err) {
			return false
		}
	}
	return true
}

func sortedKeys(m map[string]interface{}) []string {
	sorted := make([]string, 0, len(m))
	for key := range m {
		sorted = append(sorted, key)
	}
	sort.Strings(sorted)
	return sorted
}
