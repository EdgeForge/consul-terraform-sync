package tftmpl

import (
	"fmt"
	"log"
	"os"
	"path"
	"sort"

	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/hashicorp/hcl/v2/hclwrite"
	"github.com/hashicorp/terraform/configs/hcl2shim"
	"github.com/zclconf/go-cty/cty"
)

const (
	// TerraformRequiredVersion is the version constraint pinned to the generated
	// root module to ensure compatibility across Consul NIA, Terraform, and
	// modules.
	TerraformRequiredVersion = ">=0.13"

	// RootFilename is the file name for the root module.
	RootFilename = "main.tf"
)

var (
	// RootPreamble is a warning message included to the beginning of the
	// generated root module.
	RootPreamble = []byte(
		`# This main.tf is generated by Consul NIA.
#
#	The HCL blocks, arguments, variables, and values are derived from the
# operator configuration for Consul NIA. Any manual changes to this file
# may not be preserved and could be clobbered by a subsequent update.

`)
)

// Task contains information for a Consul NIA task. The Terraform driver
// interprets task values for determining the Terraform module.
type Task struct {
	Description string
	Name        string
	Source      string
	Version     string
}

// RootModuleInputData is the input data used to generate the root module
type RootModuleInputData struct {
	Backend   map[string]interface{}
	Providers []map[string]interface{}
	Task      Task
}

// NewRootModule creates an HCL file object that contains the blocks and
// arguments needed for the root module.
func NewRootModule(input RootModuleInputData) (*hclwrite.File, error) {
	f := hclwrite.NewEmptyFile()
	rootBody := f.Body()

	// Terraform block to declare the version constraint
	tfBlock := rootBody.AppendNewBlock("terraform", nil)
	tfBody := tfBlock.Body()
	tfBody.SetAttributeValue("required_version", cty.StringVal(TerraformRequiredVersion))

	// Configure the Terraform backend within the Terraform block
	// Remove one layer of nesting to use for block label
	var backendLabel string
	var backendBlock map[string]interface{}
	for label, block := range input.Backend {
		backendLabel = label
		backendBlock = block.(map[string]interface{})
		break
	}
	backendBody := tfBody.AppendNewBlock("backend", []string{backendLabel}).Body()
	sortedBackendAttr := sortKeys(backendBlock)
	for _, attr := range sortedBackendAttr {
		val := backendBlock[attr]
		backendBody.SetAttributeValue(attr, hcl2shim.HCL2ValueFromConfigValue(val))
	}
	rootBody.AppendNewline()

	// Provider blocks
	for _, p := range input.Providers {
		// Remove one layer of the nesting to use for block label
		var providerName string
		var providerBlock map[string]interface{}
		for label, block := range p {
			providerName = label
			providerBlock = block.(map[string]interface{})
			break
		}
		providerBody := rootBody.AppendNewBlock("provider", []string{providerName}).Body()

		// Convert user provider attr+values to provider block arguments from variables
		// and sort the attributes for consistency
		// attr = var.<providerName>.<attr>
		sortedProviderAttr := sortKeys(providerBlock)
		for _, attr := range sortedProviderAttr {
			// Drop the alias meta attribute. Each provider instance will be ran as
			// a separate task
			if attr == "alias" {
				continue
			}

			providerBody.SetAttributeTraversal(attr, hcl.Traversal{
				hcl.TraverseRoot{Name: "var"},
				hcl.TraverseAttr{Name: providerName},
				hcl.TraverseAttr{Name: attr},
			})
		}
		rootBody.AppendNewline()
	}

	// Module block
	// Add user description for task above the module block
	if input.Task.Description != "" {
		appendComment(rootBody, input.Task.Description)
	}
	moduleBlock := rootBody.AppendNewBlock("module", []string{input.Task.Name})
	moduleBody := moduleBlock.Body()
	moduleBody.SetAttributeValue("source", cty.StringVal(input.Task.Source))
	if len(input.Task.Version) > 0 {
		moduleBody.SetAttributeValue("version", cty.StringVal(input.Task.Version))
	}
	rootBody.AppendNewline()
	moduleBody.SetAttributeTraversal("services", hcl.Traversal{
		hcl.TraverseRoot{Name: "var"},
		hcl.TraverseAttr{Name: "services"},
	})

	return f, nil
}

// InitRootModule generates the root module and writes the main.tf file to disk
func InitRootModule(input RootModuleInputData, dir string, force bool) error {
	modulePath := path.Join(dir, input.Task.Name)
	fullPath := path.Join(modulePath, RootFilename)

	if fileExists(fullPath) {
		if !force {
			log.Printf("[DEBUG] (templates.terraform) root module for task %q "+
				"already exists, skipping file creation", input.Task.Name)
			return nil
		} else {
			log.Printf("[INFO] (templates.terraform) overwriting root module for "+
				"task %q", input.Task.Name)
		}
	}
	os.MkdirAll(modulePath, os.ModePerm)

	module, err := NewRootModule(input)
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] (templates.terraform) creating root module for task %q: %s",
		input.Task.Name, fullPath)

	f, err := os.Create(fullPath)
	if err != nil {
		return err
	}

	_, err = f.Write(RootPreamble)
	if err != nil {
		log.Printf("[WARN] (templates.terraform) unable to write preamble warning to %q", RootFilename)
	}
	_, err = module.WriteTo(f)
	return err
}

func fileExists(name string) bool {
	if _, err := os.Stat(name); err != nil {
		if os.IsNotExist(err) {
			return false
		}
	}
	return true
}

func appendComment(b *hclwrite.Body, comment string) {
	b.AppendUnstructuredTokens(hclwrite.Tokens{
		{
			Type:  hclsyntax.TokenComment,
			Bytes: []byte(fmt.Sprintf("# %s", comment)),
		},
	})
	b.AppendNewline()
}

func sortKeys(m map[string]interface{}) []string {
	sorted := make([]string, 0, len(m))
	for key := range m {
		sorted = append(sorted, key)
	}
	sort.Strings(sorted)
	return sorted
}
