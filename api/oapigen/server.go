// Package oapigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.3 DO NOT EDIT.
package oapigen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Gets all tasks
	// (GET /v1/tasks)
	GetAllTasks(w http.ResponseWriter, r *http.Request)
	// Creates a new task
	// (POST /v1/tasks)
	CreateTask(w http.ResponseWriter, r *http.Request, params CreateTaskParams)
	// Marks a task for deletion
	// (DELETE /v1/tasks/{name})
	DeleteTaskByName(w http.ResponseWriter, r *http.Request, name string)
	// Gets a task by name
	// (GET /v1/tasks/{name})
	GetTaskByName(w http.ResponseWriter, r *http.Request, name string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetAllTasks operation middleware
func (siw *ServerInterfaceWrapper) GetAllTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAllTasks(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateTask operation middleware
func (siw *ServerInterfaceWrapper) CreateTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateTaskParams

	// ------------- Optional query parameter "run" -------------
	if paramValue := r.URL.Query().Get("run"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "run", r.URL.Query(), &params.Run)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTask(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTaskByName operation middleware
func (siw *ServerInterfaceWrapper) DeleteTaskByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", chi.URLParam(r, "name"), &name)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter name: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTaskByName(w, r, name)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTaskByName operation middleware
func (siw *ServerInterfaceWrapper) GetTaskByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", chi.URLParam(r, "name"), &name)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter name: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTaskByName(w, r, name)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/tasks", wrapper.GetAllTasks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/tasks", wrapper.CreateTask)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/tasks/{name}", wrapper.DeleteTaskByName)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/tasks/{name}", wrapper.GetTaskByName)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
