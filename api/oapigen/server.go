// Package oapigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.10.1 DO NOT EDIT.
package oapigen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Gets health status
	// (GET /v1/health)
	GetHealth(w http.ResponseWriter, r *http.Request)
	// Gets all tasks
	// (GET /v1/tasks)
	GetAllTasks(w http.ResponseWriter, r *http.Request)
	// Creates a new task
	// (POST /v1/tasks)
	CreateTask(w http.ResponseWriter, r *http.Request, params CreateTaskParams)
	// Marks a task for deletion
	// (DELETE /v1/tasks/{name})
	DeleteTaskByName(w http.ResponseWriter, r *http.Request, name string)
	// Gets a task by name
	// (GET /v1/tasks/{name})
	GetTaskByName(w http.ResponseWriter, r *http.Request, name string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealth(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAllTasks operation middleware
func (siw *ServerInterfaceWrapper) GetAllTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAllTasks(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateTask operation middleware
func (siw *ServerInterfaceWrapper) CreateTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateTaskParams

	// ------------- Optional query parameter "run" -------------
	if paramValue := r.URL.Query().Get("run"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "run", r.URL.Query(), &params.Run)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "run", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTask(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTaskByName operation middleware
func (siw *ServerInterfaceWrapper) DeleteTaskByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTaskByName(w, r, name)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTaskByName operation middleware
func (siw *ServerInterfaceWrapper) GetTaskByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTaskByName(w, r, name)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/health", wrapper.GetHealth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/tasks", wrapper.GetAllTasks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/tasks", wrapper.CreateTask)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/tasks/{name}", wrapper.DeleteTaskByName)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/tasks/{name}", wrapper.GetTaskByName)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
