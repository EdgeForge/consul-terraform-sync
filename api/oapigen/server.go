// Package oapigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.10.1 DO NOT EDIT.
package oapigen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Gets health status
	// (GET /v1/health)
	GetHealth(w http.ResponseWriter, r *http.Request)
	// Gets all tasks
	// (GET /v1/tasks)
	GetAllTasks(w http.ResponseWriter, r *http.Request)
	// Creates a new task
	// (POST /v1/tasks)
	CreateTask(w http.ResponseWriter, r *http.Request, params CreateTaskParams)
	// Marks a task for deletion
	// (DELETE /v1/tasks/{name})
	DeleteTaskByName(w http.ResponseWriter, r *http.Request, name string)
	// Gets a task by name
	// (GET /v1/tasks/{name})
	GetTaskByName(w http.ResponseWriter, r *http.Request, name string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealth(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAllTasks operation middleware
func (siw *ServerInterfaceWrapper) GetAllTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAllTasks(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateTask operation middleware
func (siw *ServerInterfaceWrapper) CreateTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateTaskParams

	// ------------- Optional query parameter "run" -------------
	if paramValue := r.URL.Query().Get("run"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "run", r.URL.Query(), &params.Run)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "run", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTask(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTaskByName operation middleware
func (siw *ServerInterfaceWrapper) DeleteTaskByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTaskByName(w, r, name)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTaskByName operation middleware
func (siw *ServerInterfaceWrapper) GetTaskByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTaskByName(w, r, name)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/health", wrapper.GetHealth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/tasks", wrapper.GetAllTasks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/tasks", wrapper.CreateTask)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/tasks/{name}", wrapper.DeleteTaskByName)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/tasks/{name}", wrapper.GetTaskByName)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"r668c9xdr/4bAAD//6FLGIAqNwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
