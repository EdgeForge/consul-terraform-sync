// Package oapigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.3 DO NOT EDIT.
package oapigen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Creates a new task
	// (POST /v1/tasks)
	CreateTask(w http.ResponseWriter, r *http.Request, params CreateTaskParams)
	// Marks a task for deletion
	// (DELETE /v1/tasks/{name})
	DeleteTaskByName(w http.ResponseWriter, r *http.Request, name string)
	// Gets a task by name
	// (GET /v1/tasks/{name})
	GetTaskByName(w http.ResponseWriter, r *http.Request, name string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// CreateTask operation middleware
func (siw *ServerInterfaceWrapper) CreateTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateTaskParams

	// ------------- Optional query parameter "run" -------------
	if paramValue := r.URL.Query().Get("run"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "run", r.URL.Query(), &params.Run)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTask(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTaskByName operation middleware
func (siw *ServerInterfaceWrapper) DeleteTaskByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", chi.URLParam(r, "name"), &name)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter name: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTaskByName(w, r, name)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTaskByName operation middleware
func (siw *ServerInterfaceWrapper) GetTaskByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", chi.URLParam(r, "name"), &name)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter name: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTaskByName(w, r, name)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/tasks", wrapper.CreateTask)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/tasks/{name}", wrapper.DeleteTaskByName)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/tasks/{name}", wrapper.GetTaskByName)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
