//go:build e2e
// +build e2e

package e2e

import (
	"fmt"
	"path/filepath"
	"strings"
	"testing"

	"github.com/hashicorp/consul-terraform-sync/api"
	"github.com/hashicorp/consul-terraform-sync/config"
	"github.com/hashicorp/consul-terraform-sync/testutils"
	"github.com/hashicorp/consul/sdk/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestE2E_ServiceRegistration_Defaults(t *testing.T) {
	setParallelism(t)
	srv := testutils.NewTestConsulServer(t, testutils.TestConsulServerConfig{
		HTTPSRelPath: "../testutils",
	})
	defer srv.Stop()
	tempDir := fmt.Sprintf("%s%s", tempDirPrefix, "registration")
	taskName := "registration_w_consul"
	module := "mkam/hello/cts"

	cts := ctsSetup(t, srv, tempDir, moduleTaskConfig(taskName, module))

	// Find CTS service by name since ID is autogenerated
	name := config.DefaultServiceName
	ctsServices := getServiceInstancesByName(t, srv, name)
	require.Equal(t, 1, len(ctsServices), "CTS service not registered as %s", name)
	var service testutils.Service
	for _, s := range ctsServices {
		service = s
	}

	// Verify service attributes
	id := service.ID
	assert.True(t, strings.HasPrefix(id, "cts-"),
		"unexpected format for generated service ID %s", service.ID)
	assert.Equal(t, name, service.Service)
	assert.Equal(t, cts.Port(), service.Port)
	assert.Equal(t, []string{"cts"}, service.Tags)

	// Verify health check for service
	checkID := id + "-health"
	check, err := testutils.WaitForCheckStatus(t, srv, checkID, "passing", defaultWaitForCheckUpdate)
	require.NoError(t, err)
	assert.Equal(t, "http", check.Type)
	assert.Equal(t, "CTS Health Status", check.Name)
	assert.Equal(t, "passing", check.Status)
	assert.Equal(t, "Check created by Consul-Terraform-Sync", check.Notes)
	assert.Equal(t, service.ID, check.ServiceID)
	assert.Equal(t, name, check.ServiceName)
	assert.Equal(t, service.Tags, []string{"cts"})
	url := fmt.Sprintf("http://localhost:%d/v1/health", cts.Port())
	assert.Contains(t, check.Output, url)
}

func TestE2E_ServiceRegistration_DeregisterWhenStopped(t *testing.T) {
	setParallelism(t)
	srv := newTestConsulServer(t)
	defer srv.Stop()

	tempDir := fmt.Sprintf("%s%s", tempDirPrefix, "cts_stop_deregister")
	cleanup := testutils.MakeTempDir(t, tempDir)
	defer cleanup()

	id := "cts-01"
	configPath := filepath.Join(tempDir, configFile)
	config := baseConfig(tempDir).appendID(id).
		appendConsulBlock(srv).appendTerraformBlock().appendDBTask()
	config.write(t, configPath)

	// Start CTS, verify that service is registered
	cts, stop := api.StartCTS(t, configPath)
	err := cts.WaitForTestReadiness(defaultWaitForTestReadiness)
	require.NoError(t, err)
	testutils.WaitForConsulServiceRegistered(t, srv, id, defaultWaitForRegistration)
	registered := testutils.ServiceRegistered(t, srv, id)
	assert.True(t, registered)

	// Stop CTS, check that service is deregistered
	stop(t)
	testutils.WaitForConsulServiceDeregistered(t, srv, id, defaultWaitForRegistration)
	registered = testutils.ServiceRegistered(t, srv, id)
	assert.False(t, registered)
}

func getServiceInstancesByName(t testing.TB, srv *testutil.TestServer, serviceName string) map[string]testutils.Service {
	filter := fmt.Sprintf(`Service == "%s"`, serviceName)
	return testutils.ListServices(t, srv, filter)
}
